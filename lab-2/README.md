# Лабораторная работа №2. «Последовательная логика»

Вариант 6:

| Вариант | Функция 1    | FSM     | Функция 2 | Разрядности | Делитель частоты |
| ---     | ---          | ---     | ---       | ---         | ---              |
| 6       | `COUNT_FREE` | `FSM_1` | `ARBITER` | 8 бит       | 5                |

## Задание

Полный текст задания находится в документе [lab-2-task.pdf](./docs/lab-2-task.pdf).

Выдержка с описанием основной цели:

> Лабораторная работа №2 посвящена проектированию последовательностной логики
> на уровне регистровых передач с использованием языка описания аппаратуры
> Verilog HDL. 
>
> В первой части работы предлагается разработать несколько простых блоков
> цифровой последовательностной логики и объединить их для выполнения заданной
> функции в одно функционирующее устройство. 
>
> Во второй части работы предлагается разработать устройство, управляющее
> входным потоком данных с помощью одного из указанных алгоритмов обработки.

### Описание элементов

3.3 Конечные автоматы

У вас имеется ограниченное число блоков сумматора, умножителя на 2 и делителя на 2. На
их основе вам необходимо реализовать заданные функции. Разрядность операндов указана
в варианте. Разрядность результата определяется студентом. В рамках этого задания,
запрещено пользоваться операторами -, * и /, а так же соответствующим им встроенным
функциям-примитивам языка Verliog

3.3.1 `FSM_1`

Один сумматор, один умножитель, два делителя.

`(A/2+B)*8 + (A-B/2)*4`

3.5.4 Функция `COUNT_FREE`

> Необходимо после прошествия определенного количества времени сформировать
> однобитный сигнал запроса. Информацию о количестве тактов, после которого
> необходимо формировать сигнал, устройство получает по однобитному
> последовательностному порту запроса. Необходимые сигналы в интерфейсе вашего
> модуля:

| Порт | Тип | Описание |
| --- | --- | --- |
| `clk`  | Вх. | Сигнал тактовой частоты. |
| `rst`  | Вх. | Асинхронный сигнал сброса. |
| `start_req_i` | Вх. | Сигнал запроса. Представляет собой сигнал валидности для однобитного сигнала входных данных. |
| `start_data_i` | Вх. | Однобитный сигнал данных, представляющий собой один разряд исходного числа. |
| `ready_i` | Вх. | Сигнал готовности внешнего устройства принять результат. |
| `result_rsp_o` | Вых. | Сигнал готовности результата. Выставляется в высокий уровень тогда и только тогда, когда на шине данных установлен корректный результат. Держится в высоком состоянии ровно один период тактового сигнала, когда внешнее устройство готово принять результат; в противном случае держится в высоком состоянии до тех пор, пока устройство не будет готово принять результат. |
| `busy_o` | Вых. | Сигнал занятости устройства. |

3.6 Сложно-функциональный блок

> В рамках второй части задания необходимо реализовать модуль, выполняющий
> определенную процедуру обработки входного потока данных. Все внутренние
> элементы памяти вашего модуля должны тактироваться от делителя частоты и
> обладать сигналами разрешения и асинхронного сброса

3.6.1 Модуль “ARBITER” 

> На входе у модуля имеются четыре независимых
> интерфейса подачи транзакций. По каждому из этих интерфейсов в любой момент
> времени может поступить транзакция, которая должна быть передана на
> единственный выходной порт. В случае, если в модуль одновременно приходят
> несколько транзакций, то они должны быть обработаны по алгоритму Round-Robin.
> Интерфейс подачи транзакции должен включать в себя шину данных и
> соответствующий ей сигнал валидности данных. Выходной интерфейс также
> включает в себя шину данных и сигнал готовности результата. Помимо этого в
> вашем модуле необходимо реализовать сигнал готовности устройства принять
> данные на обработку. Разрядность данных устанавливается в соответствии с
> вариантом.

- https://youtu.be/NNTHpNSDaIA?t=866 — про арбитры

- - -

## Комментарии

В лабах подразумевается использование именно Verilog, а не SystemVerilog (т.е.
более строгая типизация, нет enum, варианций always).

На начальных этапах построение модулей происходит через построение схем и
разбиение ее на части с последовательной логикой и комбинаторной. Между частями
правильно нужно передавать данные. Так код писать понятнее, чем с помощью высокоуровневых операций.


# Лабораторная работа №2. «Последовательная логика»

Вариант 6:

| Вариант | Функция 1    | FSM     | Функция 2 | Разрядности | Делитель частоты |
| ---     | ---          | ---     | ---       | ---         | ---              |
| 6       | `COUNT_FREE` | `FSM_1` | `ARBITER` | 8 бит       | 5                |


Выдержка с описанием основной цели:

> Лабораторная работа №2 посвящена проектированию последовательностной логики
> на уровне регистровых передач с использованием языка описания аппаратуры
> Verilog HDL. 
>
> В первой части работы предлагается разработать несколько простых блоков
> цифровой последовательностной логики и объединить их для выполнения заданной
> функции в одно функционирующее устройство. 
>
> Во второй части работы предлагается разработать устройство, управляющее
> входным потоком данных с помощью одного из указанных алгоритмов обработки.

## Задание

Полный текст задания находится в документе [lab-2-task.pdf](./docs/lab-2-task.pdf).

### 2.2.2 Порядок выполнения работы

#### Часть 1.

1. В соответствии с требованиями вашего варианта, постройте микроархитектурные
   диаграммы:
    - Счётчика;
    - Сдвигового регистра;
    - Конечного автомата;
    - Делителя частоты;
2. Опишите ваши схемы на Verilog HDL;
3. Подумайте о том, как протестировать каждую из ваших схем отдельно. Напишите
   тестовый план.
4. Разработайте эталонные модели и тестовое окружение. Проведите тестирование
   всех ваших схем, доказывающее их работоспособность.
5. Разработайте высокоуровневую диаграмму устройства, которое выполняет
   заданную вариантом функцию, на основе ранее разработанных простейших блоков;
6. Подумайте о том, как протестировать устройство целиком. Напишите тестовый
   план.
7. Разработайте эталонные модели и тестовое окружение. Проведите тестирование
   разработанного устройства, которое докажет его работоспособность;
8. Подумайте над тем, как можно оптимизировать разработанную вами схему, при
   условии отсутствия ограничений;

#### Часть 2.

1. В соответствии с требованиями вашего варианта, постройте микроархитектурную
   диаграмму устройства.
2. Напишите тестовый план;
3. Разработайте эталонные модели и тестовое окружение. Проведите тестирование
   разработанного устройства, которое докажет его работоспособность;

### Описание элементов

3.3 Конечные автоматы

У вас имеется ограниченное число блоков сумматора, умножителя на 2 и делителя на 2. На
их основе вам необходимо реализовать заданные функции. Разрядность операндов указана
в варианте. Разрядность результата определяется студентом. В рамках этого задания,
запрещено пользоваться операторами -, * и /, а так же соответствующим им встроенным
функциям-примитивам языка Verliog

3.3.1 `FSM_1`

Один сумматор, один умножитель, два делителя.

`(A/2+B)*8 + (A-B/2)*4`

3.5.4 Функция `COUNT_FREE`

> Необходимо после прошествия определенного количества времени сформировать
> однобитный сигнал запроса. Информацию о количестве тактов, после которого
> необходимо формировать сигнал, устройство получает по однобитному
> последовательностному порту запроса. Необходимые сигналы в интерфейсе вашего
> модуля:

| Порт | Тип | Описание |
| --- | --- | --- |
| `clk`  | Вх. | Сигнал тактовой частоты. |
| `rst`  | Вх. | Асинхронный сигнал сброса. |
| `start_req_i` | Вх. | Сигнал запроса. Представляет собой сигнал валидности для однобитного сигнала входных данных. |
| `start_data_i` | Вх. | Однобитный сигнал данных, представляющий собой один разряд исходного числа. |
| `ready_i` | Вх. | Сигнал готовности внешнего устройства принять результат. |
| `result_rsp_o` | Вых. | Сигнал готовности результата. Выставляется в высокий уровень тогда и только тогда, когда на шине данных установлен корректный результат. Держится в высоком состоянии ровно один период тактового сигнала, когда внешнее устройство готово принять результат; в противном случае держится в высоком состоянии до тех пор, пока устройство не будет готово принять результат. |
| `busy_o` | Вых. | Сигнал занятости устройства. |

3.6 Сложно-функциональный блок

> В рамках второй части задания необходимо реализовать модуль, выполняющий
> определенную процедуру обработки входного потока данных. Все внутренние
> элементы памяти вашего модуля должны тактироваться от делителя частоты и
> обладать сигналами разрешения и асинхронного сброса

3.6.1 Модуль “ARBITER” 

> На входе у модуля имеются четыре независимых
> *интерфейса* подачи транзакций. По каждому из этих интерфейсов в любой момент
> времени может поступить транзакция, которая должна быть передана на
> единственный *выходной порт*. В случае, если в модуль одновременно приходят
> несколько транзакций, то они должны быть обработаны по алгоритму Round-Robin.
> Интерфейс подачи транзакции должен включать в себя 
> - шину данных и
> - соответствующий ей сигнал валидности данных. 
> Выходной интерфейс также
> - включает в себя шину данных и 
> - сигнал готовности результата. 
> Помимо этого в вашем модуле необходимо реализовать сигнал готовности
> устройства принять данные на обработку. Разрядность данных устанавливается в
> соответствии с вариантом.

- https://youtu.be/NNTHpNSDaIA?t=866 — про арбитры

Детали реализации:
- транзакция — шина данных и сигнал валидности, при установке которого данные на шине не меняются, время ее обработки не принципиаьлно;
- это не алгоритм Round-Robin на самом деле, это фиксированные приоритеты по порядку;
- можно использовать один сигнал `ready_o`, который отключать в момент обработки транцакции;
- транзакция на выходе держится один такт.


- - -

## Комментарии

В лабах подразумевается использование именно Verilog, а не SystemVerilog (т.е.
более строгая типизация, нет enum, варианций always).

На начальных этапах построение модулей происходит через построение схем и
разбиение ее на части с последовательной логикой и комбинаторной. Между частями
правильно нужно передавать данные. Так код писать понятнее, чем с помощью высокоуровневых операций.

1. В соответствии с требованиями вашего варианта, постройте микроархитектурную
   диаграмму устройства.
2. Напишите тестовый план;
3. Разработайте эталонные модели и тестовое окружение. Проведите тестирование
   разработанного устройства, которое докажет его работоспособность;

### Описание элементов

3.3 Конечные автоматы

У вас имеется ограниченное число блоков сумматора, умножителя на 2 и делителя на 2. На
их основе вам необходимо реализовать заданные функции. Разрядность операндов указана
в варианте. Разрядность результата определяется студентом. В рамках этого задания,
запрещено пользоваться операторами -, * и /, а так же соответствующим им встроенным
функциям-примитивам языка Verliog

3.3.1 `FSM_1`

Один сумматор, один умножитель, два делителя.

`(A/2+B)*8 + (A-B/2)*4`

- - -

- https://youtu.be/O-gQYpP8Lf8 —  *Занятие 3 (2023-24): Концепция конечного автомата в цифровой электронике.*

3.5.4 Функция `COUNT_FREE`

> Необходимо после прошествия определенного количества времени сформировать
> однобитный сигнал запроса. Информацию о количестве тактов, после которого
> необходимо формировать сигнал, устройство получает по однобитному
> последовательностному порту запроса. Необходимые сигналы в интерфейсе вашего
> модуля:

| Порт | Тип | Описание |
| --- | --- | --- |
| `clk`  | Вх. | Сигнал тактовой частоты. |
| `rst`  | Вх. | Асинхронный сигнал сброса. |
| `start_req_i` | Вх. | Сигнал запроса. Представляет собой сигнал валидности для однобитного сигнала входных данных. |
| `start_data_i` | Вх. | Однобитный сигнал данных, представляющий собой один разряд исходного числа. |
| `ready_i` | Вх. | Сигнал готовности внешнего устройства принять результат. |
| `result_rsp_o` | Вых. | Сигнал готовности результата. Выставляется в высокий уровень тогда и только тогда, когда на шине данных установлен корректный результат. Держится в высоком состоянии ровно один период тактового сигнала, когда внешнее устройство готово принять результат; в противном случае держится в высоком состоянии до тех пор, пока устройство не будет готово принять результат. |
| `busy_o` | Вых. | Сигнал занятости устройства. |

3.6 Сложно-функциональный блок

> В рамках второй части задания необходимо реализовать модуль, выполняющий
> определенную процедуру обработки входного потока данных. Все внутренние
> элементы памяти вашего модуля должны тактироваться от делителя частоты и
> обладать сигналами разрешения и асинхронного сброса

3.6.1 Модуль “ARBITER” 

> На входе у модуля имеются четыре независимых
> *интерфейса* подачи транзакций. По каждому из этих интерфейсов в любой момент
> времени может поступить транзакция, которая должна быть передана на
> единственный *выходной порт*. В случае, если в модуль одновременно приходят
> несколько транзакций, то они должны быть обработаны по алгоритму Round-Robin.
> Интерфейс подачи транзакции должен включать в себя 
> - шину данных и
> - соответствующий ей сигнал валидности данных. 
> Выходной интерфейс также
> - включает в себя шину данных и 
> - сигнал готовности результата. 
> Помимо этого в вашем модуле необходимо реализовать сигнал готовности
> устройства принять данные на обработку. Разрядность данных устанавливается в
> соответствии с вариантом.

- - -

- https://youtu.be/NNTHpNSDaIA?t=866 — *Занятие 24 (2023-24)Арбитры и*
  *разделение памяти между несколькими процессорными ядрами.Когерентность*
- https://youtu.be/F0jAIuDaFD0?t=1833 — Применение арбитра в контроллере

- - -

## Комментарии

В лабах подразумевается использование именно Verilog, а не SystemVerilog (т.е.
более строгая типизация, нет enum, варианций always).

- имеются различные типы в Verilog и SystemVerilog:
  - https://www.chipverify.com/verilog/verilog-data-types 
  - https://www.chipverify.com/systemverilog/systemverilog-datatypes   

На начальных этапах построение модулей происходит через построение схем и
разбиение ее на части с последовательной логикой и комбинаторной. Между частями
правильно нужно передавать данные. Так код писать понятнее, чем с помощью высокоуровневых операций.

Эталонные модели должны описываться с помощью высокоуровневых средств языка (по
крайней мере другими, отличными от основной реализации), например, типами `Integer`, циклами `for` и прочим.

Для простой штуки типа сдвигавого регистра возможно всё таки не имеет смысла
делать. Мне разрешили вообще не делать эталонные модели.
